Тестовый проект для запуска на базе STM32F103VET6

Суть проекта (обзор функций):

* Стандартный запуск W5500:
  Сокеты 0,1,2 инициализированы для DHCP и DNS клиентов, а также дефолтного HTTP-сервера (это уже по описанию ioLibrary от WizNet).
  Сокет 3 зарезервирован под одно TelNet соединение (изменить номер сокета можно из файла telnetConfigServer.h)

Порядок сборки:

1. Создаём проект в CubeIDE или что там у вас будет.
2. Настраиваем кварцы (ну как обычно)
3. Инициализируем SPI шину - ниже скриншот основных настроек:

![изображение](https://user-images.githubusercontent.com/88036227/145385076-16cfa267-9a4a-4c59-bc63-5a87ac0395bd.png)

DMA не используется.
Глобальное прерывание SPI - надо включить. Без него основной контроллер тупит на приём и вместо корректных ответов получает белеберду.
На SPIx_MISO не забываем включить подтяжку Pull-Up - у W5500 все ноги выхода - открытый коллектор.

4. Инициализируем I2C шину (на дисплей SSD1306), настройки ниже:

![изображение](https://user-images.githubusercontent.com/88036227/145447110-f988a02f-ec4d-4cca-b177-9dd470014127.png)
![изображение](https://user-images.githubusercontent.com/88036227/145447182-d11abb40-46db-4b3b-83c4-2ef8b02cb916.png)
![изображение](https://user-images.githubusercontent.com/88036227/145447255-642695b2-38db-4747-84f3-4cc310c3b129.png)

5. Включаем прерывания: 

![изображение](https://user-images.githubusercontent.com/88036227/145453043-d4ff9cfd-7681-4252-8922-25a4ca2062d5.png)

6. В папку с проектом в раздел Drivers добавляем папку /wiznet/*
7. В main.c добавляем подвязки к w5500 и параметрам:
#include "w5500_defines.h"
#include "parameters.h"
8. Инициируем массив управляемых параметров:
parameter_record params[PARAMS_COUNT];
В основном цикле инициируем подключение массива к сокету управляемых параметров:
linkParametersStorage(&params,PARAMS_COUNT);
Потом устанавливаем начальные значения параметров. В коде за это действие отвечает метод main.c/initParameters();
Порядок создания переменной:
    1. Присваиваем ей имя, для вызова в сокете.
    2. Указываем из перечислителя parameter_formats соответствующий тип переменной. Не перепутай! Если связать 4-байтное целое, а указать, что это double - будет весёлая кракозябра.
    3. Если надо создаём статичную переменную размерностей, соответствующую указанному типу данных и заполняем. В примере такие размерности были заданы для строк. Если переменная - число, можно не указывать. Подтянется значение для типа данных по умолчанию. Если надо заведомо ограничить, чтоб не вписали дичь - лучше занести
Например так: "string_dimensions st_var_f = {.charsCount = 30};"
    4. Подключаем переменную размерностей: params[5].dimensions = &st_var_f;
    5. Подвязываем к созданной структуре реальную переменную: params[і].value = &var_a; (так же подвязывается и колбек, если указать тип MACROS. Важно - колбеки блокирующие. Хочешь что-то длительное сделать - подними колбеком флаг, а работай в отдельном потоке.

Основные критерии: каждая переменная или вызываемый коллбек должны иметь своё уникальное имя без пробелов. Вызов имени в сокете регистронезависимый, так что в идеале всё писать капсом.

9. Настройка W5500 почти стандартная - все действия к ней вынесены в w5500_defines.h
  1.  Создаём переменную стартовой конфигурации типа wiz_NetInfo - в неё заносим изначальные настройки сервера. В этом коде ведущим является местный DHCP-сервер. Поскольку переменная конфигурации не статичная, имеем следующий эффект: при подключении кабеля идёт запрос к местному DHCP-серверу в виде 10 попыток. Нет ответа - стандартная конфигурация. Если после включения уже был один захват адреса - он и останется. Т. е. если DHCP-сервер упал - адрес у устройства останется тот же. 
  2.  Прописываем методы чтения и записи в W5500 - в коде для этого использовался HAL.
  3.  Прописываем методы установки уровня на выводах CS и RESET у W5500. 
  4.  Прописываем в прерывании SysTick (можно использовать любой другой таймер с тиком в 1 сек) ежесекундный вызов DHCP_time_handler(); Без этого зависнет на подключении кабеля.
  5.  Прописываем в прерывании на ноге W5500_INT вызов реакции на прерывание от сокета telnetConfigServer_InterruptCallback() (без этого не будет работать диалог - пишешь в рельсу) и других.

Ну и всё - должно работать :)
